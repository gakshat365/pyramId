
1

Automatic Zoom
Phase4_DnA25.md2025-11-13
 / 
Project Phase 4
Submission Deadline: 20th November 2025, 11:59 PM
1. Introduction and Objectives
This final project phase marks the culmination of your design efforts. The primary objective is to translate
the conceptual "Mini World" relational schema, developed in Phase 3, into a tangible, functional, and
populated database system.
You will implement your database schema in MySQL, populate it with comprehensive data that brings your
Mini World to life, and develop a Python-based application interface to interact with this data. This phase
tests your proficiency in database creation, data management, and the practical application of SQL for data
retrieval and manipulation.
Core Objectives:
1. Database Implementation: To correctly translate your final relational schema (from Phase 3) into a
set of CREATE TABLE statements in MySQL, accurately enforcing all primary keys, foreign keys,
constraints, and data types.
2. Data Population: To populate your database with a substantial and coherent set of legitimate data
that reflects your chosen "Mini World" theme. This data must be sufficient to test all functional
requirements meaningfully.
3. Application Development: To build a robust Python application that serves as an interface to your
database.
4. Functional Requirements: To implement all functional requirements specified in the project
(including the minimum of 5 distinct queries and 3 update operations) using raw SQL commands
executed from your Python application.
2. Core Project Components
This project is divided into two primary parts: the database backend (SQL) and the application frontend
(Python).
Part A: Database Implementation (SQL)
This part involves creating the database structure and filling it with data. This work should be encapsulated
in two separate .sql files for organization and repeatability.
1. Schema Creation (schema.sql)
You must create one SQL script named schema.sql. When executed, this script should:
1. Create your database (e.g., CREATE DATABASE IF NOT EXISTS mini_world_db;).
2. Select your database (USE mini_world_db;).
3. Define and create all tables from your relational schema.
4. Pay meticulous attention to:
Phase4_DnA25.md2025-11-13
 / 
Data Types: Select the most appropriate type for each attribute (e.g., INT, VARCHAR(255), TEXT,
DATE, DECIMAL(10, 2), ENUM).
Primary Keys: Define a primary key for every table (PRIMARY KEY).
Foreign Keys: Correctly define all foreign key relationships (FOREIGN KEY ... REFERENCES ...).
Referential Integrity: Specify ON DELETE and ON UPDATE actions (e.g., ON DELETE CASCADE,
ON DELETE SET NULL, ON UPDATE CASCADE) as logically appropriate for your world's rules.
Constraints: Enforce data integrity using NOT NULL, UNIQUE, and CHECK constraints where
applicable.
2. Data Population (populate.sql)
You must create a second SQL script named populate.sql. This script will contain all the INSERT INTO
statements necessary to populate your tables.
Data Quality: Data must be realistic and coherent within the context of your Mini World. Avoid
simple placeholder data (e.g., 'test1', 'test2').
Data Quantity: You must insert enough data to demonstrate all your application's functional
requirements effectively. This includes populating tables to allow for complex queries (e.g., data that
will and will not match JOIN conditions) and having data that can be safely updated or deleted.
Insertion Order: Be mindful of foreign key constraints. You must insert data into parent tables (e.g.,
Worlds) before inserting data into child tables that reference them (e.g., Characters).
Part B: Application Interface (Python)
This part involves building the application that users will interact with.
1. Database Connectivity
Your Python application must connect to your MySQL database using a library such as PyMySQL or mysql-
connector-python. Hard-coding credentials directly in the main script is discouraged for production
systems, but for this project, you may place them in a configuration function. All database operations
(queries, updates) must be executed through this connection.
2. User Interface (UI)
Baseline Requirement: The minimum requirement is a Command Line Interface (CLI). This can be
built using simple input() and print() functions in a loop, presenting users with a menu of options that
correspond to your functional requirements.
Optional Enhancements (No Extra Marks): Teams may choose to implement a more sophisticated
interface, such as a graphical user interface (GUI) with Tkinter or a web application with a micro-
framework like Flask. While this can improve usability, it is strictly optional and will not factor into
your grade. The evaluation is based on the database implementation, data quality, and the
correctness of the SQL-backed functional requirements, regardless of the interface's complexity.
3. Functional Requirements Implementation
This is the most critical aspect of the application. Your interface must provide access to all functional
requirements defined for your project.
Phase4_DnA25.md2025-11-13
 / 
Minimums: You must implement at least five distinct query (read) operations and three distinct
update (write) operations (INSERT, UPDATE, DELETE).
SQL Purity: You must write raw SQL queries as strings within your Python code. You are not
permitted to use an ORM (Object-Relational Mapper) or any high-level library functions that abstract
away the SQL query (e.g., pandas.to_sql).
Parameterized Query Example (PyMySQL):
INCORRECT (Vulnerable):
  # DO NOT DO THIS   
  world_name = input("Enter world: ")   
  cursor.execute(f"SELECT * FROM Worlds WHERE world_name = '{world_name}'") 
CORRECT (Secure):
  # DO THIS   
  world_name = input("Enter world: ")   
  sql_query = "SELECT * FROM Worlds WHERE world_name = %s"   
  cursor.execute(sql_query, (world_name,)) 
3. Boilerplate Code Examples (Mini World Theme)
Below are simplified boilerplate examples.
Example schema.sql (Structure)
DROP DATABASE IF EXISTS mini_world_db;   
CREATE DATABASE mini_world_db;   
USE mini_world_db;   
CREATE TABLE Worlds (   
    world_id INT AUTO_INCREMENT PRIMARY KEY,   
    world_name VARCHAR(100) NOT NULL UNIQUE,   
    description TEXT   
    -- ... other attributes   
);   
-- ... etc.
Example main_app.py (Python CLI Application Structure)
import pymysql   
import sys   
from getpass import getpass 
 
def get_db_connection(db_user, db_pass, db_host, db_name):   
